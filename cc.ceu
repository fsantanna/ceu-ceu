println(...)

pass :Tk

val f-name = ...[1]
val f-hand = `:pointer fopen($f-name.Dyn->Ncast.Vector.buf, "r")`
defer {
    `fclose($f-hand.Pointer);`
}

do :unnest {
    func letter? (c) {
        `char c = $c.Char;`
        `:bool ((c>='a' && c<='z') || (c>='A' && c<='Z'))`
    }
    func digit? (c) {
        `char c = $c.Char;`
        `:bool (c>='0' && c<='9')`
    }
    func letter-or-digit? (c) {
        letter?(c) or digit?(c)
    }
}

^["tokens.ceu"]
;;val KEYWORDS = vector-to-dict(^["tokens.ceu"])

data :Pos = [lin,col]
var POS :Pos = [1,0]

do :unnest {
    var buf = nil
    var cur = nil

    func f-read-c () {
        if buf {
            val c = buf
            set buf = nil
            c
        } else {
            val b = `:number fgetc($f-hand.Pointer)`
            set cur = if b == `:number EOF` {
                nil
            } else {
                `:char $b.Number`
            }
            cur
        } thus c {
            set POS = if (c == '\n') -> [POS.lin+1,0] -> [POS.lin,POS.col+1]
            c
        }
    }

    func f-unread-c () {
        assert(not buf)
        set buf  = cur
        set POS  = if (cur == '\n') -> [POS.lin-1,col] -> [POS.lin,POS.col-1]
            where {
                val col = 0 ;; TODO: should remember from previous line
            }
    }

    func f-read-until-f (f-pred) {
        val str = #[]
        loop in iter(f-read-c), x until f-pred(x) {
            set str[+] = x
        }
        move(str)
    }

    func f-read-until-c (c) {
        f-read-until-f \{ it == c }
    }

    func f-read-while-f (f-pred) {
        defer {
            f-unread-c()
        }
        f-read-until-f \{ not f-pred(it) }
    }

    func f-read-while-c (c) {
        f-read-while-f \{ it == c }
    }
}

val co-skip = spawn coro {
    yield()
    loop in iter(f-read-c), c {
        ifs c {
            it in? [' ','\t','\n'] {}
            it == ';' {
                val c2 = f-read-c()
                if c2 /= ';' {
                    f-unread-c()
                    yield(';')
                } else {
                    f-read-until-c('\n')
                }
            }
            else -> yield(c)
        }
    }
}

func dict-any-key-f? (v, f) {
    loop in iter(v,:key), x {
    } until f(x)
}

val co-token = spawn coro {
    yield()
    loop in iter(co-skip), c {
        val pos :tmp = copy(POS)
        ifs {
            c in? ['}','(',')','[',']',',','$','\\'] {
                yield(:Tk.Fix.Sym [pos, to-string(c)])
            }
            c == ':' {               ;; TAG
            }
            digit?(c) {              ;; NUM
                f-unread-c()
                f-read-while-f \{
                    (it == '.') or letter-or-digit?(it)
                } thus num {
                    yield(:Tk.Num [pos,num])
                }
            }
            letter?(c) or (c=='_') { ;; KEY, ID
                f-unread-c()
                f-read-while-f \{
                    letter-or-digit?(it) or (it in? ['_','\'','?','!'])
                } thus id {
                    val tag = string-to-tag(":Tk.Fix."++id)
                    ifs {
                        tag  -> yield(tags([pos], tag, true))
                        else -> yield(:Tk.Id [pos,id])
                    }
                }
            }
            else {
                yield(:Tk.TODO [c,copy(POS)])
            }
        }
    }
}

loop in iter(co-token), tk {
    println(tags(tk), tk)
}

;;;
func {>>|>>} (x1, x2) {
    resume
}

val x = (coroutine(co-char) >>|>> coroutine(co-skip)) >>|>> coroutine(co-token)

        val c = `:char $n.Number`
        println(n, c)
println(f-name, f-hand)
;;;
