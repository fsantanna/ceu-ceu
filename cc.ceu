println(...)

pass :Tk

val f-name = ...[1]
val f = `:pointer fopen($f-name.Dyn->Ncast.Vector.buf, "r")`
defer {
    `fclose($f.Pointer);`
}

val tks =
func tks-read () {
}

do :unnest {
    var i   = 0
    var N   = 0
    val buf = [nil,nil]

    func f-read () {
        if N > 0 {
            val a = buf[i]
            set i = (i + 1) % 2
            set N = N - 1
            a
        } else {
            val b = `:number fgetc($f.Pointer)`
            if b == `:number EOF` {
                nil
            } else {
                `:char $b.Number`
            }
        }
    }

    func f-unread (c) {
        assert(N < 2)
        set buf[i] = c
        set i = (i + 1) % 2
        set N = N + 1
    }
}

val co-skip = spawn coro {
    yield()
    loop in iter(f-read), c {
        ifs c {
            in? [' ','\t','\n'] -> {}
            == ';' -> {
                val c2 = f-read()
            }
            else -> yield(c)
        }
    }
}

val co-token = spawn coro {
    yield()
    loop in iter(co-skip), c {
        ifs c {
            in? ['}','(',')','[',']',',','$'] -> yield(:Tk.Fix [c, []])
            else -> yield(c)
        }
    }
}

loop in iter(co-token), tk {
    println(tk)
}

;;;
func {>>|>>} (x1, x2) {
    resume
}

val x = (coroutine(co-char) >>|>> coroutine(co-skip)) >>|>> coroutine(co-token)

        val c = `:char $n.Number`
        println(n, c)
println(f-name, f)
;;;
